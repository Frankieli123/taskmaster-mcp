{
  "tasks": [
    {
      "id": 1,
      "title": "项目设置与基础UI框架搭建",
      "description": "初始化项目结构，建立主窗口，并实现基于标签页的核心导航界面，为服务商管理、模型配置和项目配置等模块提供容器。",
      "details": "使用前端框架（如Electron with React/Vue）搭建应用骨架。\n1. 创建主进程文件 `main.js` 和渲染进程文件 `renderer.js`。\n2. 设计主应用窗口，尺寸可调，并设置标题为 \"TaskMaster UI配置工具\"。\n3. 实现一个多标签页布局，包含 \"服务商管理\"、\"模型配置\"、\"配置管理\" 和 \"日志查看\" 四个主要标签页。\n4. 每个标签页暂时使用占位符内容，确保切换逻辑正常工作。\n\n**伪代码:**\n```javascript\n// main.js\napp.on('ready', () => {\n  const mainWindow = new BrowserWindow({ width: 800, height: 600 });\n  mainWindow.loadFile('index.html');\n});\n\n// renderer.js\nsetupTabs(['服务商管理', '模型配置', '配置管理', '日志查看']);\n```",
      "testStrategy": "启动应用，验证主窗口是否正确显示。点击不同标签页，检查内容区域是否相应切换，且无视觉错误。",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "核心配置管理功能实现",
      "description": "开发配置文件的读取、写入、导入、导出和重置功能，为整个应用提供数据持久化基础。",
      "details": "实现一个 `ConfigManager` 类来处理所有与 `config.json` 相关的操作。\n1.  **路径管理**: 实现一个功能，允许用户通过文件对话框选择 TaskMaster 项目路径，并将此路径保存到应用本地存储中。\n2.  **自动加载**: 应用启动时，自动检测并加载项目路径下的 `config.json` 文件。\n3.  **导入/导出**: 添加 \"导入配置\" 和 \"导出配置\" 按钮，允许用户选择 JSON 文件进行导入或将当前配置保存到指定位置。\n4.  **重置功能**: 实现 \"重置为默认配置\" 功能，恢复到预设的初始配置状态。\n5.  **保存功能**: 提供一个 `saveConfig(data)` 方法，供其他模块调用以保存更改。\n\n**伪代码:**\n```javascript\nclass ConfigManager {\n  constructor(projectPath) { this.configFile = path.join(projectPath, 'config.json'); }\n  load() { return JSON.parse(fs.readFileSync(this.configFile)); }\n  save(data) { fs.writeFileSync(this.configFile, JSON.stringify(data, null, 2)); }\n  reset() { /* 恢复默认配置 */ }\n}\n```",
      "testStrategy": "通过UI选择一个项目路径，验证路径是否被保存。手动修改配置文件后重启应用，验证数据是否自动加载。测试导入、导出和重置功能，并检查对应的 `config.json` 文件内容是否正确更新。",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "服务商管理模块开发",
      "description": "实现服务商的添加、编辑和删除功能，包括UI表单和与配置文件的交互逻辑。",
      "details": "在 \"服务商管理\" 标签页中实现 CRUD 功能。\n1.  **UI设计**: 左侧显示服务商列表，右侧为表单区域，用于添加或编辑服务商信息（如名称, API Key, Base URL）。\n2.  **添加功能**: \"添加服务商\" 按钮清空表单。用户填写完毕后，点击 \"保存\" 将新服务商数据存入 `ConfigManager`。\n3.  **编辑功能**: 点击列表中的服务商，其信息将填充到右侧表单中以供编辑。\n4.  **删除功能**: 每个服务商旁提供 \"删除\" 按钮，点击后弹出确认对话框，确认后从配置中移除该服务商。\n5.  **数据绑定**: 服务商列表应与 `ConfigManager` 中的数据动态绑定，任何更改都应实时反映在UI上。",
      "testStrategy": "添加一个新的服务商，验证其是否出现在列表中并已保存到配置文件。选择一个服务商进行编辑，修改其API Key，保存并验证文件是否更新。删除一个服务商，验证其从列表和配置文件中被移除。",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "服务商API集成与模型加载",
      "description": "实现与外部AI服务商的API联通性测试，并从服务商处动态加载可用模型列表。",
      "details": "在服务商编辑表单区域添加功能按钮。\n1.  **API连接测试**: 添加 \"测试连接\" 按钮。点击后，使用表单中的 API Key 和 Base URL，向服务商的 `v1/models` 端点发起一个授权请求。\n2.  **模型加载**: 添加 \"加载模型\" 按钮。点击后，向服务商的 `v1/models` 端点发起请求，获取模型列表，并将返回的模型数据（如 `id`）存储在配置中与该服务商关联。\n3.  **反馈机制**: API 调用期间，UI应显示加载状态。调用成功或失败时，需通过通知（Notification/Toast）向用户显示明确的结果信息（如 \"连接成功\" 或 \"错误：API密钥无效\"）。\n\n**伪代码:**\n```javascript\nasync function testConnection(apiKey, baseUrl) {\n  try {\n    const response = await fetch(`${baseUrl}/v1/models`, { headers: { 'Authorization': `Bearer ${apiKey}` } });\n    return response.ok ? '连接成功' : '连接失败';\n  } catch (error) {\n    return `网络错误: ${error.message}`;\n  }\n}\n```",
      "testStrategy": "输入一个有效的服务商配置，点击 \"测试连接\"，验证是否提示成功。输入无效的API Key，验证是否提示认证失败。点击 \"加载模型\"，验证是否成功获取模型列表并保存到该服务商的配置项下。",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "模型配置模块开发",
      "description": "实现模型的添加、编辑和删除功能，允许用户管理与特定服务商关联的模型及其参数。",
      "details": "在 \"模型配置\" 标签页中实现模型管理功能。\n1.  **UI设计**: 使用下拉菜单让用户选择一个服务商。下方是一个列表，显示该服务商下已配置的模型。\n2.  **添加模型**: 提供 \"添加模型\" 功能，弹出一个表单，让用户从该服务商已加载的模型ID列表中选择一个模型，并配置其特定参数（如别名、温度、top_p等）。\n3.  **编辑与删除**: 列表中每一项都应有关联的 \"编辑\" 和 \"删除\" 按钮，功能类似于服务商管理。\n4.  **数据结构**: 模型数据应作为服务商配置下的一个子对象数组进行存储。",
      "testStrategy": "选择一个服务商，添加一个新模型配置，保存后验证数据是否正确写入配置文件。编辑该模型的参数（如温度），保存并验证更新。删除该模型，验证其是否从配置文件中移除。",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "TaskMaster集成与模型测试",
      "description": "实现单个模型的API调用测试功能，并确保生成的配置能被TaskMaster核心程序正确使用。",
      "details": "在模型配置列表中，为每个模型添加一个 \"测试模型\" 按钮。\n1.  **API调用**: 点击按钮后，构造一个符合服务商API规范的 `chat/completions` 请求，使用该模型的配置参数（如 `model`, `temperature`）和一段预设的测试 prompt。\n2.  **结果显示**: 将API返回的结果显示在一个模态窗口或日志区域，方便用户验证模型是否按预期工作。\n3.  **TaskMaster兼容性**: 确保此工具生成的 `config.json` 文件结构与TaskMaster主程序的要求完全一致。手动或通过脚本验证TaskMaster能否使用导出的配置成功运行任务。",
      "testStrategy": "对一个已配置的模型点击 \"测试模型\"，验证是否能成功调用API并返回预期的文本结果。导出配置文件，用TaskMaster主程序加载该配置并执行一个简单任务，验证集成是否成功。",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "全局交互与反馈机制优化",
      "description": "完善整个应用的用户界面交互，包括表单验证、错误提示、通知和日志查看功能。",
      "details": "这是一个全局性的任务，涉及所有UI界面。\n1.  **表单验证**: 对所有输入字段（如API Key、URL）实施即时验证。必填项为空或格式不正确时，应有明确的视觉提示（如红色边框）和错误信息。\n2.  **统一通知系统**: 创建一个通知服务，用于显示成功信息、警告和错误。所有异步操作（如API调用、文件操作）都应使用此服务反馈结果。\n3.  **日志查看器**: 在 \"日志查看\" 标签页中，实现一个简单的日志面板，用于记录关键操作（如API请求与响应、文件读写、错误堆栈），帮助用户和开发者排查问题。",
      "testStrategy": "尝试在服务商表单中不填写API Key直接保存，验证是否有表单验证提示。故意触发一个API连接失败，验证是否有全局错误通知弹出。执行几项操作后，切换到日志标签页，验证相关操作是否被记录。",
      "priority": "low",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "最终功能审查与打包",
      "description": "进行全面的端到端功能测试，修复发现的缺陷，并准备应用的可分发版本。",
      "details": "1.  **功能演练**: 按照PRD中的功能检查清单，系统地测试每一个功能点，包括所有CRUD操作、API集成、配置管理和UI交互。\n2.  **错误处理测试**: 模拟各种异常情况，如网络中断、文件只读、API返回非预期格式等，确保程序有合理的容错和恢复机制。\n3.  **用户体验审查**: 检查应用的整体流程是否顺畅，反馈是否清晰，有无体验上的痛点。\n4.  **打包与分发**: 使用 `electron-builder` 或类似工具，将应用打包成适用于不同操作系统（Windows, macOS, Linux）的安装程序。",
      "testStrategy": "执行完整的测试用例，确保所有功能符合预期，无严重bug。打包应用并在一个干净的环境中（如虚拟机）成功安装和运行。最终生成的应用应能让用户顺畅完成从零开始配置服务商和模型，并导出可用配置文件的全过程。",
      "priority": "medium",
      "dependencies": [
        6,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "测试任务",
      "description": "创建一个简单的Hello World程序",
      "details": "编写一个输出Hello World的程序",
      "testStrategy": "",
      "status": "done",
      "dependencies": [],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "测试FoApi AI功能",
      "description": "验证FoApi模型是否能正常工作，包括对模型的输入输出进行详细测试，确保其在不同场景下的表现符合预期。",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "这是一个手动创建的任务，用于测试系统功能。测试将包括以下步骤：1) 准备多种输入数据；2) 记录模型的输出；3) 验证输出是否符合预期结果；4) 进行边界条件测试。",
      "testStrategy": "使用手动测试方法，结合不同的输入场景，确保FoApi模型在各种情况下的稳定性和准确性。",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "编写Hello World程序",
      "description": "创建一个简单的程序，其唯一功能是输出“Hello, World!”。此任务旨在验证基本的开发环境和代码执行流程是否正常。",
      "details": "1. 选择项目的主要编程语言（如Python或JavaScript）。\n2. 创建一个名为 `hello_world.py` 或 `hello_world.js` 的新文件。\n3. 在文件中编写代码，使用标准输出函数打印字符串 'Hello, World!'。\n4. 确保代码不依赖于任何外部库或项目特定模块，保持其独立性。",
      "testStrategy": "1. 通过命令行或集成开发环境（IDE）的终端执行该程序。\n2. 验证控制台的输出内容是否为 'Hello, World!'，不多不少。\n3. 确认程序执行后正常退出，返回码为0。",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "测试FoApi模型生成Python求和函数",
      "description": "创建一个调用FoApi模型的测试，要求其生成一个简单的Python函数来计算两个数的和，以验证模型的基础代码生成能力。",
      "details": "1. 准备向FoApi模型发送的请求输入。输入内容应为：'请创建一个简单的Python函数来计算两个数的和'。\n2. 编写一个测试脚本，该脚本将上述输入发送到FoApi模型的API接口。\n3. 接收并记录模型返回的完整响应。\n4. 重点检查响应中是否包含一个结构正确、逻辑清晰的Python代码块。",
      "testStrategy": "1. 运行测试脚本，确认对FoApi的API调用能够成功返回，状态码为200。\n2. 验证返回的内容不为空，并且包含Python代码。\n3. 人工审查生成的代码，确保它定义了一个函数，接受两个参数，并返回它们的和（例如，`def sum(a, b): return a + b`）。\n4. （可选）将生成的代码片段提取出来，使用示例输入（如5和10）执行，并断言结果是否为15，以自动化验证其正确性。",
      "status": "pending",
      "dependencies": [
        10
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "测试FoApi模型生成JavaScript邮箱验证函数",
      "description": "创建一个调用FoApi模型的测试，要求其生成一个简单的JavaScript函数来验证邮箱格式，以检验模型在Web前端开发场景下的代码生成能力。",
      "details": "1. 准备向FoApi模型发送的请求输入。输入内容应为：'请创建一个简单的JavaScript函数来验证邮箱格式'。\n2. 编写一个测试脚本，该脚本将上述输入发送到FoApi模型的API接口。\n3. 接收并记录模型返回的完整响应。\n4. 重点检查响应中是否包含一个使用正则表达式（RegExp）进行邮箱格式验证的JavaScript函数。\n5. 确保生成的函数逻辑正确，能够处理常见的邮箱格式。",
      "testStrategy": "1. 执行调用FoApi的测试脚本，并验证API请求成功返回。\n2. 检查API响应内容，确认其中包含一个JavaScript代码块。\n3. 提取生成的JavaScript函数，并集成到一个简单的测试环境（如HTML页面或Node.js脚本）中。\n4. 使用一组有效的邮箱地址（如 'test@example.com', 'user.name+alias@domain.co.uk'）调用该函数，并验证返回值为 `true`。\n5. 使用一组无效的邮箱地址（如 'test@.com', 'user@domain', '@domain.com'）调用该函数，并验证返回值为 `false`。",
      "status": "pending",
      "dependencies": [
        10,
        12
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "测试FoApi模型生成斐波那契数列的Python函数",
      "description": "创建一个调用FoApi模型的测试，要求其生成一个能够计算斐波那契数列的Python函数。此任务旨在评估模型处理基本算法和递归逻辑的能力。",
      "details": "1. 准备向FoApi模型发送的请求输入。输入内容应为：'请创建一个Python函数来计算斐波那契数列'。\n2. 编写一个测试脚本，该脚本将上述输入发送到FoApi模型的API接口。\n3. 接收并记录模型返回的完整响应。\n4. 重点检查响应中是否包含一个实现了斐波那契数列计算逻辑（无论是迭代或递归）的Python函数。\n5. 确保生成的代码遵循Python的最佳实践。",
      "testStrategy": "1. 执行测试脚本，向FoApi模型发送请求。\n2. 审查模型返回的Python代码，确保其语法正确且逻辑清晰。\n3. 独立运行生成的斐波那契函数，并使用多个输入值（例如，n=0, 1, 5, 10）进行测试。\n4. 验证函数的输出是否与预期的斐波那契数（F(0)=0, F(1)=1, F(5)=5, F(10)=55）一致。\n5. 确认测试通过，即模型成功生成了功能正确的代码。",
      "status": "pending",
      "dependencies": [
        10,
        12
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "测试FoApi模型生成JavaScript密码强度验证函数",
      "description": "创建一个调用FoApi模型的测试，要求其生成一个JavaScript函数来验证密码强度。此任务旨在检验模型在Web前端开发场景下的代码生成能力，并验证其处理特定指令前缀的功能。",
      "details": "1. 准备向FoApi模型发送的请求输入。输入内容应为：'测试修复后的foapi自动去前缀：创建一个JavaScript函数来验证密码强度'。\n2. 编写一个测试脚本，将上述输入发送到FoApi模型的API接口。\n3. 接收并记录模型返回的完整响应。\n4. 重点检查响应中是否包含一个功能完整的JavaScript函数，该函数应能根据密码的长度、大小写字母、数字和特殊字符等标准来评估密码强度。\n5. 确认模型生成的代码中不包含输入指令中的前缀'测试修复后的foapi自动去前缀：'。",
      "testStrategy": "1. 执行测试脚本，向FoApi模型发送预设的指令。\n2. 检查API调用是否成功返回，并且响应中包含JavaScript代码。\n3. 验证生成的JavaScript函数逻辑是否正确，可以通过提供不同强度的密码（例如：'12345'、'password123'、'Password@123'）来测试函数的返回值。\n4. 确认返回的代码是纯净的JavaScript函数，没有任何不相关的指令前缀文本。",
      "status": "pending",
      "dependencies": [
        10,
        12,
        13
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "测试foapi简单任务",
      "description": "测试foapi模型是否能正常生成简单任务",
      "details": "",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "测试T供应商的gpt-4.1-mini模型生成Python乘积函数",
      "description": "创建一个调用T供应商gpt-4.1-mini模型的测试，要求其生成一个简单的Python函数来计算两个数的乘积，以验证模型的基础代码生成能力。",
      "details": "1. 准备向T供应商的gpt-4.1-mini模型发送的请求输入，内容为：'请创建一个简单的Python函数来计算两个数的乘积'。\n2. 编写一个测试脚本，将该输入发送到gpt-4.1-mini模型的API接口。\n3. 接收并记录模型返回的完整响应。\n4. 重点检查响应中是否包含一个结构正确、逻辑清晰的Python函数代码块，该函数能够正确计算两个输入数的乘积。\n5. 确保生成的代码符合Python编码规范，且无语法错误。\n6. 记录测试结果和模型表现，便于后续分析和比较。",
      "testStrategy": "1. 运行测试脚本，发送请求并获取模型响应。\n2. 检查响应内容，确认包含一个Python函数定义，函数名和参数合理。\n3. 手动或自动执行生成的函数，输入多个测试用例（如(2,3), (0,5), (-1,4)），验证输出是否为正确的乘积。\n4. 确认代码无语法错误且符合Python最佳实践。\n5. 记录测试通过与否及任何异常情况。",
      "status": "pending",
      "dependencies": [
        12
      ],
      "priority": "medium",
      "subtasks": []
    }
  ]
}